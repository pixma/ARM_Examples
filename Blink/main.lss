
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000630  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000008  40000000  40000000  00008630  2**2
                  ALLOC
  2 .stack        00000c00  40000100  40000100  00008630  2**4
                  CONTENTS
  3 .comment      0000006c  00000000  00000000  00009230  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000d0  00000000  00000000  000092a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00000139  00000000  00000000  00009370  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000471  00000000  00000000  000094a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000284  00000000  00000000  0000991a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000031b  00000000  00000000  00009b9e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000148  00000000  00000000  00009ebc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000001b8  00000000  00000000  0000a004  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000114  00000000  00000000  0000a1bc  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__Vectors>:
// Exception Vectors
// Mapped to Address 0.
// Absolute addressing mode must be used.

__Vectors:        LDR     PC,Reset_Addr         
   0:	e59ff018 	ldr	pc, [pc, #24]	; 20 <T_Bit>
                LDR     PC,Undef_Addr
   4:	e59ff018 	ldr	pc, [pc, #24]	; 24 <PLLCFG_Val>
                LDR     PC,SWI_Addr
   8:	e59ff018 	ldr	pc, [pc, #24]	; 28 <SWI_Addr>
                LDR     PC,PAbt_Addr
   c:	e59ff018 	ldr	pc, [pc, #24]	; 2c <PAbt_Addr>
                LDR     PC,DAbt_Addr
  10:	e59ff018 	ldr	pc, [pc, #24]	; 30 <VIC_vect_offs>
                NOP                            /* Reserved Vector */
  14:	e1a00000 	nop			(mov r0,r0)
//                LDR     PC,IRQ_Addr
//                LDR     PC,[PC, #-0x0FF0]      /* Vector from VicVectAddr */
                LDR     PC,IRQ_Wrapper_Addr
  18:	e59ff018 	ldr	pc, [pc, #24]	; 38 <IRQ_Wrapper_Addr>
                LDR     PC,FIQ_Addr
  1c:	e59ff018 	ldr	pc, [pc, #24]	; 3c <FIQ_Addr>

00000020 <Reset_Addr>:
  20:	00000168 	andeq	r0, r0, r8, ror #2

00000024 <Undef_Addr>:
  24:	00000040 	andeq	r0, r0, r0, asr #32

00000028 <SWI_Addr>:
  28:	00000098 	muleq	r0, r8, r0

0000002c <PAbt_Addr>:
  2c:	00000044 	andeq	r0, r0, r4, asr #32

00000030 <DAbt_Addr>:
  30:	00000048 	andeq	r0, r0, r8, asr #32
  34:	00000000 	andeq	r0, r0, r0

00000038 <IRQ_Wrapper_Addr>:
  38:	00000050 	andeq	r0, r0, r0, asr r0

0000003c <FIQ_Addr>:
  3c:	0000004c 	andeq	r0, r0, ip, asr #32

00000040 <Undef_Handler>:

Reset_Addr:       .word     Reset_Handler
Undef_Addr:       .word     Undef_Handler
// SWI_Addr:         .word     SWI_Handler
// SWI_Wrapper_Addr: .word     SWI_Wrapper
SWI_Addr:         .word     SoftwareInterrupt      /* in swi_handler.S */
PAbt_Addr:        .word     PAbt_Handler
DAbt_Addr:        .word     DAbt_Handler
                  .word     0                      /* Reserved Address */
// IRQ_Addr:         .word     __IRQ_Handler
IRQ_Wrapper_Addr: .word    __IRQ_Wrapper
FIQ_Addr:         .word     FIQ_Handler

Undef_Handler:  B       Undef_Handler
  40:	eafffffe 	b	40 <F_Bit>

00000044 <PAbt_Handler>:
/* SWI_Handler:    B       SWI_Handler */
PAbt_Handler:   B       PAbt_Handler
  44:	eafffffe 	b	44 <PAbt_Handler>

00000048 <DAbt_Handler>:
DAbt_Handler:   B       DAbt_Handler
  48:	eafffffe 	b	48 <DAbt_Handler>

0000004c <FIQ_Handler>:
/* IRQ_Handler:    B       IRQ_Handler */
FIQ_Handler:    B       FIQ_Handler
  4c:	eafffffe 	b	4c <FIQ_Handler>

00000050 <__IRQ_Wrapper>:

.size   __Vectors, . - __Vectors



.arm
.section .init, "ax"

.if (VECTREMAPPED)
/* mthomas: Dummy used during startup - mind the nops since the 
   flash-utility will overwrite the "reserved vector"-address
   with the checksum */
				B Reset_Handler
				NOP
				NOP
				NOP
				NOP
				NOP  /* Reserved Address */
				NOP
				NOP
.endif

.arm
.section .init, "ax"
.global __startup
.func __startup
__startup:

Reset_Handler:  

.if (VPBDIV_SETUP != 0)
                LDR     R0, =VPBDIV
                LDR     R1, =VPBDIV_Val
                STR     R1, [R0]
.endif


.if (PLL_SETUP != 0)
                LDR     R0, =PLL_BASE
                MOV     R1, #0xAA
                MOV     R2, #0x55

// Configure and Enable PLL
                MOV     R3, #PLLCFG_Val
                STR     R3, [R0, #PLLCFG_OFS] 
                MOV     R3, #PLLCON_PLLE
                STR     R3, [R0, #PLLCON_OFS]
                STR     R1, [R0, #PLLFEED_OFS]
                STR     R2, [R0, #PLLFEED_OFS]

// Wait until PLL Locked
PLL_Loop:       LDR     R3, [R0, #PLLSTAT_OFS]
                ANDS    R3, R3, #PLLSTAT_PLOCK
                BEQ     PLL_Loop

// Switch to PLL Clock
                MOV     R3, #(PLLCON_PLLE | PLLCON_PLLC)
                STR     R3, [R0, #PLLCON_OFS]
                STR     R1, [R0, #PLLFEED_OFS]
                STR     R2, [R0, #PLLFEED_OFS]
.endif


.if (MAM_SETUP != 0)
                LDR     R0, =MAM_BASE
                MOV     R1, #MAMTIM_Val
                STR     R1, [R0, #MAMTIM_OFS] 
                MOV     R1, #MAMCR_Val
                STR     R1, [R0, #MAMCR_OFS] 
.endif


// Memory Mapping
                .set MEMMAP, 0xE01FC040  /* Memory Mapping Control */

.if (REMAP)
                LDR     R0, =MEMMAP
.if     (EXTMEM_MODE)                
                MOV     R1, #3
.elseif (RAM_MODE) || (VECTREMAPPED)
.print "MEMMAP to 2 on init"
                MOV     R1, #2
.else
                MOV     R1, #1
.endif
                STR     R1, [R0]
.endif

// Setup Stack for each mode
                LDR     R0, =Top_Stack

// Enter Undefined Instruction Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_UND|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #UND_Stack_Size

// Enter Abort Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_ABT|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #ABT_Stack_Size

// Enter FIQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_FIQ|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #FIQ_Stack_Size

// Enter IRQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_IRQ|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #IRQ_Stack_Size

// Enter Supervisor Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_SVC|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #SVC_Stack_Size

// Enter User Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_USR /* Interrupts enabled */
//				MSR     CPSR_c, #Mode_USR|I_Bit|F_Bit /* Interrupts disabled */
                MOV     SP, R0


.if (RAM_MODE==0)
/* Relocate .data section (Copy from ROM to RAM) */
                LDR     R1, =_etext 
                LDR     R2, =_data 
                LDR     R3, =_edata 
                CMP     R2, R3
                BEQ     DataIsEmpty
LoopRel:        CMP     R2, R3 
                LDRLO   R0, [R1], #4 
                STRLO   R0, [R2], #4 
                BLO     LoopRel 
DataIsEmpty:
.endif
 
/* Clear .bss section (Zero init) */
                MOV     R0, #0 
                LDR     R1, =__bss_start__ 
                LDR     R2, =__bss_end__ 
                CMP     R1,R2
                BEQ     BSSIsEmpty
LoopZI:         CMP     R1, R2 
                STRLO   R0, [R1], #4 
                BLO     LoopZI 
BSSIsEmpty:


// call C++ constructors of global objects
		LDR 	r0, =__ctors_start__
		LDR 	r1, =__ctors_end__
ctor_loop:
		CMP 	r0, r1
		BEQ 	ctor_end
		LDR 	r2, [r0], #4
		STMFD 	sp!, {r0-r1}
		MOV 	lr, pc
		MOV 	pc, r2
		LDMFD 	sp!, {r0-r1}
		B 		ctor_loop
ctor_end:

// Enter the C code
                //LDR     R0,=INIT
                LDR     R0,=main
                TST     R0,#1             // Bit-0 set: main is Thumb
                LDREQ   LR,=__exit_ARM    // ARM Mode
                LDRNE   LR,=__exit_THUMB  // Thumb Mode
                BX      R0

.size   __startup, . - __startup
.endfunc

.arm
.global __exit_ARM
.func __exit_ARM
__exit_ARM:
                B       __exit_ARM
.size   __exit_ARM, . - __exit_ARM
.endfunc

.thumb
.global __exit_THUMB
.func __exit_THUMB
__exit_THUMB:
                B       __exit_THUMB
.size   __exit_THUMB, . - __exit_THUMB
.endfunc


/* mthomas: the following code is inspired by various examples and
   documents from ARM, Atmel, Anglia Designs and others */


.text
.arm

.if (VECTREMAPPED)
.print "Handlers in section .vectmapped -> .data"
.section .vectmapped, "ax"
.else
.print "Handlers in section .vectorg -> .code/.text"
.section .vectorg, "ax"
.endif

.set VIC_base_addr, 0xFFFFF000
.set VIC_vect_offs, 0x30

        .arm
        .global __IRQ_Wrapper
        .func   __IRQ_Wrapper
__IRQ_Wrapper:
/*- Manage Exception Entry  */
/*- Adjust and save LR_irq in IRQ stack  */
            sub         lr, lr, #4
  50:	e24ee004 	sub	lr, lr, #4	; 0x4
            stmfd       sp!, {lr}
  54:	e92d4000 	stmdb	sp!, {lr}

/*- Save SPSR need to be saved for nested interrupt */
            mrs         r14, SPSR
  58:	e14fe000 	mrs	lr, SPSR
            stmfd       sp!, {r14}
  5c:	e92d4000 	stmdb	sp!, {lr}

/*- Save and r0 in IRQ stack  */
            stmfd       sp!, {r0}
  60:	e92d0001 	stmdb	sp!, {r0}

/*- Write in the IVR to support Protect Mode  */
/*- No effect in Normal Mode  */
/*- De-assert the NIRQ and clear the source in Protect Mode */
/* R14 = LR */
            ldr         r14, =VIC_base_addr
  64:	e59fe028 	ldr	lr, [pc, #40]	; 94 <.text+0x94>
            ldr         r0 , [r14, #VIC_vect_offs]
  68:	e59e0030 	ldr	r0, [lr, #48]
            /*str         r14, [r14, #VIC_vect_offs]*/

/*- Enable Interrupt and Switch in Supervisor Mode */
            msr         CPSR_c, #Mode_SVC
  6c:	e321f013 	msr	CPSR_c, #19	; 0x13

/*- Save scratch/used registers and LR in User Stack */
            /*stmfd       sp!, { r1-r3, r12, r14}*/
            stmfd       sp!, { r1-r12, r14 }
  70:	e92d5ffe 	stmdb	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

/*- Branch to the routine pointed by the VIC-Vector-Address  */
            mov         r14, pc
  74:	e1a0e00f 	mov	lr, pc
            bx          r0
  78:	e12fff10 	bx	r0
/*- Restore scratch/used registers and LR from User Stack*/
            /* ldmia       sp!, { r1-r3, r12, r14} */
            ldmia       sp!, { r1-r12, r14 }
  7c:	e8bd5ffe 	ldmia	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

/*- Disable Interrupt and switch back in IRQ mode */
            msr         CPSR_c, #I_Bit | Mode_IRQ
  80:	e321f092 	msr	CPSR_c, #146	; 0x92

#if 0
/* VICVectAddr=0 is already done in the ISRs of the Philips-Examples 
   so commented out here */
/*- Mark the End of Interrupt on the VIC */
            ldr         r14, =VIC_base_addr
            str         r14, [r14, #VIC_vect_offs]
#endif

/*- Restore SPSR_irq and r0 from IRQ stack */
            ldmia       sp!, {r0}
  84:	e8bd0001 	ldmia	sp!, {r0}

/*- Restore SPSR_irq and r0 from IRQ stack */
            ldmia       sp!, {r14}
  88:	e8bd4000 	ldmia	sp!, {lr}
            msr         SPSR_cxsf, r14
  8c:	e16ff00e 	msr	SPSR_fsxc, lr

/*- Restore adjusted  LR_irq from IRQ stack directly in the PC */
            ldmia       sp!, {pc}^
  90:	e8fd8000 	ldmia	sp!, {pc}^
  94:	fffff000 	undefined instruction 0xfffff000

00000098 <SoftwareInterrupt>:
.global SoftwareInterrupt
.func   SoftwareInterrupt
SoftwareInterrupt:
SWI_HandlerMT:
	STMFD   sp!, {r4, lr}      /* store regs. */
  98:	e92d4010 	stmdb	sp!, {r4, lr}
	MRS     r4, spsr
  9c:	e14f4000 	mrs	r4, SPSR
	TST     r4, #T_Bit             /* test for thumb */
  a0:	e3140020 	tst	r4, #32	; 0x20
	LDRNEH  r4, [lr, #-2]          /* NE->thumb - get swi instruction code */
  a4:	115e40b2 	ldrneh	r4, [lr, #-2]
	BICNE   r4, r4, #0xff00        /* NE->thumb - clear top 8 bits leaving swi "comment field"=number */
  a8:	13c44cff 	bicne	r4, r4, #65280	; 0xff00
	LDREQ   r4, [lr, #-4]          /* EQ->arm - get swi instruction code */
  ac:	051e4004 	ldreq	r4, [lr, #-4]
	BICEQ   r4, r4, #0xff000000    /* EQ->arm - clear top 8 bits leaving swi "comment field"=number */
  b0:	03c444ff 	biceq	r4, r4, #-16777216	; 0xff000000
	CMP     r4, #MAX_SWI           /* range-check */
  b4:	e3540006 	cmp	r4, #6	; 0x6
	LDRLS   pc, [pc, r4, LSL #2]   /* jump to routine if <= MAX (LS) */
  b8:	979ff104 	ldrls	pc, [pc, r4, lsl #2]

000000bc <SWIOutOfRange>:
SWIOutOfRange:
	B       SWIOutOfRange
  bc:	eafffffe 	b	bc <SWIOutOfRange>

000000c0 <SwiTableStart>:
  c0:	000000dc 	ldreqd	r0, [r0], -ip
  c4:	000000ec 	andeq	r0, r0, ip, ror #1
  c8:	000000fc 	streqd	r0, [r0], -ip
  cc:	00000110 	andeq	r0, r0, r0, lsl r1
  d0:	00000124 	andeq	r0, r0, r4, lsr #2
  d4:	0000012c 	andeq	r0, r0, ip, lsr #2
  d8:	00000148 	andeq	r0, r0, r8, asr #2

000000dc <IRQDisable>:

/* Jump-Table */
SwiTableStart:
	.word IRQDisable	// 0
	.word IRQEnable		// 1
	.word FIQDisable	// 2
	.word FIQEnable		// 3
	.word CPSRget		// 4
	.word IRQRestore	// 5
	.word FIQRestore	// 6
SwiTableEnd:
.set MAX_SWI, ((SwiTableEnd-SwiTableStart)/4)-1

IRQDisable:
	MRS     r0, SPSR                        /* Get SPSR = return value */
  dc:	e14f0000 	mrs	r0, SPSR
	ORR     r4, r0, #I_Bit                  /* I_Bit set */
  e0:	e3804080 	orr	r4, r0, #128	; 0x80
	MSR     SPSR_c, r4                      /* Set SPSR */
  e4:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI
  e8:	ea00001d 	b	164 <EndofSWI>

000000ec <IRQEnable>:

IRQEnable:
	MRS     r0, SPSR                        /* Get SPSR = return value */
  ec:	e14f0000 	mrs	r0, SPSR
	BIC     r4, r0, #I_Bit                  /* I_Bit clear */
  f0:	e3c04080 	bic	r4, r0, #128	; 0x80
	MSR     SPSR_c, r4                      /* Set SPSR */
  f4:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI                       
  f8:	ea000019 	b	164 <EndofSWI>

000000fc <FIQDisable>:

FIQDisable:
	MRS     r0, SPSR
  fc:	e14f0000 	mrs	r0, SPSR
	ORR     r4, r0, #F_Bit
 100:	e3804040 	orr	r4, r0, #64	; 0x40
	AND     r0, r0, #F_Bit
 104:	e2000040 	and	r0, r0, #64	; 0x40
	MSR     SPSR_c, r4
 108:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI
 10c:	ea000014 	b	164 <EndofSWI>

00000110 <FIQEnable>:

FIQEnable:
	MRS     r0, SPSR
 110:	e14f0000 	mrs	r0, SPSR
	BIC     r4, r0, #F_Bit
 114:	e3c04040 	bic	r4, r0, #64	; 0x40
	AND     r0, r0, #F_Bit
 118:	e2000040 	and	r0, r0, #64	; 0x40
	MSR     SPSR_c, r4
 11c:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI
 120:	ea00000f 	b	164 <EndofSWI>

00000124 <CPSRget>:

CPSRget:
	// LDR r0, =0xdeadbeef
	MRS     r0, SPSR                        /* Get SPSR */
 124:	e14f0000 	mrs	r0, SPSR
	B       EndofSWI                       
 128:	ea00000d 	b	164 <EndofSWI>

0000012c <IRQRestore>:

IRQRestore:
	MRS     r4, SPSR                        /* Get SPSR */
 12c:	e14f4000 	mrs	r4, SPSR
	AND     r0, r0, #I_Bit
 130:	e2000080 	and	r0, r0, #128	; 0x80
	TST     r0, #I_Bit             /* Test input for I_Bit */
 134:	e3100080 	tst	r0, #128	; 0x80
	BICEQ   r4, r4, #I_Bit
 138:	03c44080 	biceq	r4, r4, #128	; 0x80
	ORRNE   r4, r4, #I_Bit
 13c:	13844080 	orrne	r4, r4, #128	; 0x80
	MSR     SPSR_c, r4
 140:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI
 144:	ea000006 	b	164 <EndofSWI>

00000148 <FIQRestore>:

FIQRestore:
	MRS     r4, SPSR                        /* Get SPSR */
 148:	e14f4000 	mrs	r4, SPSR
	AND     r0, r0, #F_Bit
 14c:	e2000040 	and	r0, r0, #64	; 0x40
	TST     r0, #F_Bit             /* Test input for F_Bit */
 150:	e3100040 	tst	r0, #64	; 0x40
	BICEQ   r4, r4, #F_Bit
 154:	03c44040 	biceq	r4, r4, #64	; 0x40
	ORRNE   r4, r4, #F_Bit
 158:	13844040 	orrne	r4, r4, #64	; 0x40
	MSR     SPSR_c, r4
 15c:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI
 160:	eaffffff 	b	164 <EndofSWI>

00000164 <EndofSWI>:

EndofSWI:
	LDMFD   sp!, {r4,pc}^
 164:	e8fd8010 	ldmia	sp!, {r4, pc}^

00000168 <__startup>:
 168:	e59f0128 	ldr	r0, [pc, #296]	; 298 <.text+0x298>
 16c:	e3a01000 	mov	r1, #0	; 0x0
 170:	e5801000 	str	r1, [r0]
 174:	e59f0120 	ldr	r0, [pc, #288]	; 29c <.text+0x29c>
 178:	e3a010aa 	mov	r1, #170	; 0xaa
 17c:	e3a02055 	mov	r2, #85	; 0x55
 180:	e3a03024 	mov	r3, #36	; 0x24
 184:	e5803004 	str	r3, [r0, #4]
 188:	e3a03001 	mov	r3, #1	; 0x1
 18c:	e5803000 	str	r3, [r0]
 190:	e580100c 	str	r1, [r0, #12]
 194:	e580200c 	str	r2, [r0, #12]

00000198 <PLL_Loop>:
 198:	e5903008 	ldr	r3, [r0, #8]
 19c:	e2133b01 	ands	r3, r3, #1024	; 0x400
 1a0:	0afffffc 	beq	198 <PLL_Loop>
 1a4:	e3a03003 	mov	r3, #3	; 0x3
 1a8:	e5803000 	str	r3, [r0]
 1ac:	e580100c 	str	r1, [r0, #12]
 1b0:	e580200c 	str	r2, [r0, #12]
 1b4:	e59f00e4 	ldr	r0, [pc, #228]	; 2a0 <.text+0x2a0>
 1b8:	e3a01004 	mov	r1, #4	; 0x4
 1bc:	e5801004 	str	r1, [r0, #4]
 1c0:	e3a01002 	mov	r1, #2	; 0x2
 1c4:	e5801000 	str	r1, [r0]
 1c8:	e59f00d4 	ldr	r0, [pc, #212]	; 2a4 <.text+0x2a4>
 1cc:	e321f0db 	msr	CPSR_c, #219	; 0xdb
 1d0:	e1a0d000 	mov	sp, r0
 1d4:	e2400080 	sub	r0, r0, #128	; 0x80
 1d8:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
 1dc:	e1a0d000 	mov	sp, r0
 1e0:	e2400080 	sub	r0, r0, #128	; 0x80
 1e4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
 1e8:	e1a0d000 	mov	sp, r0
 1ec:	e2400080 	sub	r0, r0, #128	; 0x80
 1f0:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
 1f4:	e1a0d000 	mov	sp, r0
 1f8:	e2400c02 	sub	r0, r0, #512	; 0x200
 1fc:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
 200:	e1a0d000 	mov	sp, r0
 204:	e2400080 	sub	r0, r0, #128	; 0x80
 208:	e321f010 	msr	CPSR_c, #16	; 0x10
 20c:	e1a0d000 	mov	sp, r0
 210:	e59f1090 	ldr	r1, [pc, #144]	; 2a8 <.text+0x2a8>
 214:	e59f2090 	ldr	r2, [pc, #144]	; 2ac <.text+0x2ac>
 218:	e59f3090 	ldr	r3, [pc, #144]	; 2b0 <.text+0x2b0>
 21c:	e1520003 	cmp	r2, r3
 220:	0a000003 	beq	234 <DataIsEmpty>

00000224 <LoopRel>:
 224:	e1520003 	cmp	r2, r3
 228:	34910004 	ldrcc	r0, [r1], #4
 22c:	34820004 	strcc	r0, [r2], #4
 230:	3afffffb 	bcc	224 <LoopRel>

00000234 <DataIsEmpty>:
 234:	e3a00000 	mov	r0, #0	; 0x0
 238:	e59f1074 	ldr	r1, [pc, #116]	; 2b4 <.text+0x2b4>
 23c:	e59f2074 	ldr	r2, [pc, #116]	; 2b8 <.text+0x2b8>
 240:	e1510002 	cmp	r1, r2
 244:	0a000002 	beq	254 <BSSIsEmpty>

00000248 <LoopZI>:
 248:	e1510002 	cmp	r1, r2
 24c:	34810004 	strcc	r0, [r1], #4
 250:	3afffffc 	bcc	248 <LoopZI>

00000254 <BSSIsEmpty>:
 254:	e59f0060 	ldr	r0, [pc, #96]	; 2bc <.text+0x2bc>
 258:	e59f1060 	ldr	r1, [pc, #96]	; 2c0 <.text+0x2c0>

0000025c <ctor_loop>:
 25c:	e1500001 	cmp	r0, r1
 260:	0a000005 	beq	27c <ctor_end>
 264:	e4902004 	ldr	r2, [r0], #4
 268:	e92d0003 	stmdb	sp!, {r0, r1}
 26c:	e1a0e00f 	mov	lr, pc
 270:	e1a0f002 	mov	pc, r2
 274:	e8bd0003 	ldmia	sp!, {r0, r1}
 278:	eafffff7 	b	25c <ctor_loop>

0000027c <ctor_end>:
 27c:	e59f0040 	ldr	r0, [pc, #64]	; 2c4 <.text+0x2c4>
 280:	e3100001 	tst	r0, #1	; 0x1
 284:	059fe03c 	ldreq	lr, [pc, #60]	; 2c8 <.text+0x2c8>
 288:	159fe03c 	ldrne	lr, [pc, #60]	; 2cc <.text+0x2cc>
 28c:	e12fff10 	bx	r0

00000290 <__exit_ARM>:
 290:	eafffffe 	b	290 <__exit_ARM>

00000294 <__exit_THUMB>:
 294:	e7fe      	b.n	294 <__exit_THUMB>
 296:	0000      	lsls	r0, r0, #0
 298:	c100      	stmia	r1!, {}
 29a:	e01f      	b.n	2dc <FiqRestore+0x4>
 29c:	c080      	stmia	r0!, {r7}
 29e:	e01f      	b.n	2e0 <IntGetCPSR>
 2a0:	c000      	stmia	r0!, {}
 2a2:	e01f      	b.n	2e4 <IntGetCPSR+0x4>
 2a4:	0d00      	lsrs	r0, r0, #20
 2a6:	4000      	ands	r0, r0
 2a8:	0630      	lsls	r0, r6, #24
 2aa:	0000      	lsls	r0, r0, #0
 2ac:	0000      	lsls	r0, r0, #0
 2ae:	4000      	ands	r0, r0
 2b0:	0630      	lsls	r0, r6, #24
 2b2:	0000      	lsls	r0, r0, #0
 2b4:	0000      	lsls	r0, r0, #0
 2b6:	4000      	ands	r0, r0
 2b8:	0008      	lsls	r0, r1, #0
 2ba:	4000      	ands	r0, r0
 2bc:	0630      	lsls	r0, r6, #24
 2be:	0000      	lsls	r0, r0, #0
 2c0:	0630      	lsls	r0, r6, #24
 2c2:	0000      	lsls	r0, r0, #0
 2c4:	05c1      	lsls	r1, r0, #23
 2c6:	0000      	lsls	r0, r0, #0
 2c8:	0290      	lsls	r0, r2, #10
 2ca:	0000      	lsls	r0, r0, #0
 2cc:	0294      	lsls	r4, r2, #10
	...

000002d0 <IntRestore>:
.endfunc


/**********************************************************************
 *  Call SWI to restore IRQ
 *  Function : void IntEnable(uint32_t)
 *  Parameters:      None
 *  input  :         newstate
 *                   if I_bit in newstate cleared->IRQ on  -> clear I_BIT
 *                   if I_bit in newstate set    ->IRQ off -> set I_Bit
 *  output :         None
 **********************************************************************/
.arm
.text
.section .text, "ax"
.global IntRestore
.func   IntRestore
IntRestore:
		SWI     SWI_IRQ_REST
 2d0:	ef000005 	svc	0x00000005
		BX      lr
 2d4:	e12fff1e 	bx	lr

000002d8 <FiqRestore>:
.endfunc

/**********************************************************************
 *  Call SWI to restore FIQ
 *  Function : void IntEnable(uint32_t)
 *  Parameters:      None
 *  input  :         newstate
 *                   if F_bit in newstate cleared->FIQ on  -> clear F_BIT
 *                   if F_bit in newstate set    ->FIQ off -> set F_Bit
 *  output :         None
 **********************************************************************/
.arm
.text
.section .text, "ax"
.global FiqRestore
.func   FiqRestore
FiqRestore:
		SWI     SWI_FIQ_REST
 2d8:	ef000006 	svc	0x00000006
		BX      lr
 2dc:	e12fff1e 	bx	lr

000002e0 <IntGetCPSR>:
.endfunc

/**********************************************************************
 *  Call SWI to read IRQ/FIQ-status
 *  Function : uint32_t IntEnable(void)
 *  Parameters:      None
 *  input  :         None
 *  output :         CPSR (SPSR_SVC)
 **********************************************************************/
.arm
.text
.section .text, "ax"
.global IntGetCPSR
.func   IntGetCPSR
IntGetCPSR:
		SWI     SWI_GET_CPSR
 2e0:	ef000004 	svc	0x00000004
		BX      lr
 2e4:	e12fff1e 	bx	lr

000002e8 <IntEnable>:
.endfunc

/**********************************************************************
 *  Call SWI to enable IRQ
 *  Function : uint32_t IntEnable(void)
 *  Parameters:      None
 *  input  :         None
 *  output :         previous status
 *                   I_Bit clear if IRQs were enabled
 *                   I_Bit set   if IRQs were disabled
 **********************************************************************/
.arm
.text
.section .text, "ax"
.global IntEnable
.func   IntEnable
IntEnable:
        SWI     SWI_IRQ_EN
 2e8:	ef000001 	svc	0x00000001
        BX      lr
 2ec:	e12fff1e 	bx	lr

000002f0 <IntDisable>:
.endfunc /* end of IntEnable */

/**********************************************************************
 *  Call SWI to disable IRQ
 *  Function : uint32_t IntDisable(void)
 *  Parameters     : None
 *  input          : None
 *  output :         previous status
 *                   I_Bit clear if IRQs were enabled
 *                   I_Bit set   if IRQs were disabled
 **********************************************************************/
.arm
.global IntDisable
.section .text, "ax"
.func   IntDisable
IntDisable:
        SWI     SWI_IRQ_DIS
 2f0:	ef000000 	svc	0x00000000
        BX      lr
 2f4:	e12fff1e 	bx	lr

000002f8 <FiqEnable>:
.endfunc /* end of IntDisable */

/**********************************************************************
 *  Call SWI to enable FIQ
 *  Function : uint32_t FiqEnable(void)
 *  Parameters:      None
 *  input  :         None
 *  output :         previous status
 *                   F_Bit clear if FIQs were enabled
 *                   F_Bit set   if FIQs were disabled
 **********************************************************************/
.arm
.text
.section .text, "ax"
.global FiqEnable
.func   FiqEnable
FiqEnable:
        SWI     SWI_FIQ_EN
 2f8:	ef000003 	svc	0x00000003
        BX      lr
 2fc:	e12fff1e 	bx	lr

00000300 <FiqDisable>:
.endfunc

/**********************************************************************
 *  Call SWI to disable FIQ
 *  Function : uint32_t FiqDisable(void)
 *  Parameters     : None
 *  input          : None
 *  output :         previous status
 *                   F_Bit clear if FIQs were enabled
 *                   F_Bit set   if FIQs were disabled
 **********************************************************************/
.arm
.global FiqDisable
.section .text, "ax"
.func   FiqDisable
FiqDisable:
        SWI     SWI_FIQ_DIS
 300:	ef000002 	svc	0x00000002
        BX      lr
 304:	e12fff1e 	bx	lr

00000308 <DefaultVICHandler>:
    /* if the IRQ is not installed into the VIC, and interrupt occurs, the
    default interrupt VIC address will be used. This could happen in a race 
    condition. For debugging, use this endless loop to trace back. */
    /* For more details, see Philips appnote AN10414 */
    VICVectAddr = 0;		/* Acknowledge Interrupt */ 
 308:	e3a02000 	mov	r2, #0	; 0x0
 30c:	e3e03000 	mvn	r3, #0	; 0x0
 310:	e5032fcf 	str	r2, [r3, #-4047]
 314:	eafffffe 	b	314 <DefaultVICHandler+0xc>

00000318 <init_VIC>:
    while ( 1 );
}

/* Initialize the interrupt controller */
/******************************************************************************
** Function name:		init_VIC
**
** Descriptions:		Initialize VIC interrupt controller.
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void init_VIC(void) 
{
    DWORD i = 0;
    DWORD *vect_addr, *vect_cntl;
   	
    /* initialize VIC*/
    VICIntEnClr = 0xffffffff;
 318:	e3e03000 	mvn	r3, #0	; 0x0
    VICVectAddr = 0;
 31c:	e3a02000 	mov	r2, #0	; 0x0
 320:	e5033feb 	str	r3, [r3, #-4075]
 324:	e5032fcf 	str	r2, [r3, #-4047]
    VICIntSelect = 0;
 328:	e5032ff3 	str	r2, [r3, #-4083]
 32c:	e2422c0f 	sub	r2, r2, #3840	; 0xf00

    /* set all the vector and vector control register to 0 */
    for ( i = 0; i < VIC_SIZE; i++ )
    {
	vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + i*4);
	vect_cntl = (DWORD *)(VIC_BASE_ADDR + VECT_CNTL_INDEX + i*4);
	*vect_addr = 0;	
 330:	e3a03000 	mov	r3, #0	; 0x0
	*vect_cntl = 0;
 334:	e5823100 	str	r3, [r2, #256]
 338:	e5823000 	str	r3, [r2]
 33c:	e2822004 	add	r2, r2, #4	; 0x4
 340:	e3720d3b 	cmn	r2, #3776	; 0xec0
 344:	1afffff9 	bne	330 <init_VIC+0x18>
    }

    /* Install the default VIC handler here */
    VICDefVectAddr = (DWORD)DefaultVICHandler;   
 348:	e59f2008 	ldr	r2, [pc, #8]	; 358 <.text+0x358>
 34c:	e3e03000 	mvn	r3, #0	; 0x0
 350:	e5032fcb 	str	r2, [r3, #-4043]
    return;
}
 354:	e12fff1e 	bx	lr
 358:	00000308 	andeq	r0, r0, r8, lsl #6

0000035c <install_irq>:

/******************************************************************************
** Function name:		install_irq
**
** Descriptions:		Install interrupt handler
**				The max VIC size is 16, but, there are 32 interrupt
**				request inputs. Not all of them can be installed into
**				VIC table at the same time.
**				The order of the interrupt request installation is
**				first come first serve.
** parameters:			Interrupt number and interrupt handler address
** Returned value:		true or false, when the table is full, return false
** 
******************************************************************************/
DWORD install_irq( DWORD IntNumber, void *HandlerAddr )
{
    DWORD i;
    DWORD *vect_addr;
    DWORD *vect_cntl;
      
    VICIntEnClr = 1 << IntNumber;	/* Disable Interrupt */
 35c:	e3a03001 	mov	r3, #1	; 0x1
 360:	e52de004 	str	lr, [sp, #-4]!
 364:	e1a0e013 	mov	lr, r3, lsl r0
 368:	e3e03000 	mvn	r3, #0	; 0x0
 36c:	e503efeb 	str	lr, [r3, #-4075]
 370:	e59fc044 	ldr	ip, [pc, #68]	; 3bc <.text+0x3bc>
 374:	e3a02000 	mov	r2, #0	; 0x0
    
    for ( i = 0; i < VIC_SIZE; i++ )
    {
	/* find first un-assigned VIC address for the handler */

	vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + i*4);
	vect_cntl = (DWORD *)(VIC_BASE_ADDR + VECT_CNTL_INDEX + i*4);
	if ( *vect_addr == (DWORD)NULL )
 378:	e51c3100 	ldr	r3, [ip, #-256]
 37c:	e3530000 	cmp	r3, #0	; 0x0
 380:	e2822001 	add	r2, r2, #1	; 0x1
 384:	0a000004 	beq	39c <install_irq+0x40>
 388:	e3520010 	cmp	r2, #16	; 0x10
 38c:	e28cc004 	add	ip, ip, #4	; 0x4
 390:	1afffff8 	bne	378 <install_irq+0x1c>
	{
	    *vect_addr = (DWORD)HandlerAddr;	/* set interrupt vector */
	    *vect_cntl = (DWORD)(IRQ_SLOT_EN | IntNumber);
	    break;
	}
    }
    if ( i == VIC_SIZE )
 394:	e3a00000 	mov	r0, #0	; 0x0
 398:	ea000005 	b	3b4 <install_irq+0x58>
 39c:	e3803020 	orr	r3, r0, #32	; 0x20
 3a0:	e58c3000 	str	r3, [ip]
    {
	return( FALSE );		/* fatal error, can't find empty vector slot */
    }
    VICIntEnable = 1 << IntNumber;	/* Enable Interrupt */
 3a4:	e3e03000 	mvn	r3, #0	; 0x0
 3a8:	e50c1100 	str	r1, [ip, #-256]
 3ac:	e503efef 	str	lr, [r3, #-4079]
 3b0:	e3a00001 	mov	r0, #1	; 0x1
    return( TRUE );
}
 3b4:	e49de004 	ldr	lr, [sp], #4
 3b8:	e12fff1e 	bx	lr
 3bc:	fffff200 	undefined instruction 0xfffff200

000003c0 <uninstall_irq>:

/******************************************************************************
** Function name:		uninstall_irq
**
** Descriptions:		Uninstall interrupt handler
**				Find the interrupt handler installed in the VIC
**				based on the interrupt number, set the location
**				back to NULL to uninstall it.
** parameters:			Interrupt number
** Returned value:		true or false, when the interrupt number is not found, 
**				return false
** 
******************************************************************************/
DWORD uninstall_irq( DWORD IntNumber )
{
    DWORD i;
    DWORD *vect_addr;
    DWORD *vect_cntl;
      
    VICIntEnClr = 1 << IntNumber;	/* Disable Interrupt */
 3c0:	e3a03001 	mov	r3, #1	; 0x1
 3c4:	e1a0c013 	mov	ip, r3, lsl r0
 3c8:	e3e03000 	mvn	r3, #0	; 0x0
 3cc:	e503cfeb 	str	ip, [r3, #-4075]
 3d0:	e59f2044 	ldr	r2, [pc, #68]	; 41c <.text+0x41c>
 3d4:	e3a01000 	mov	r1, #0	; 0x0
    
    for ( i = 0; i < VIC_SIZE; i++ )
    {
	/* find first un-assigned VIC address for the handler */
	vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + i*4);
	vect_cntl = (DWORD *)(VIC_BASE_ADDR + VECT_CNTL_INDEX + i*4);
	if ( (*vect_cntl & ~IRQ_SLOT_EN ) == IntNumber )
 3d8:	e5923000 	ldr	r3, [r2]
 3dc:	e3c33020 	bic	r3, r3, #32	; 0x20
 3e0:	e1530000 	cmp	r3, r0
 3e4:	e2811001 	add	r1, r1, #1	; 0x1
 3e8:	0a000004 	beq	400 <PLLSTAT_PLOCK>
 3ec:	e3510010 	cmp	r1, #16	; 0x10
 3f0:	e2822004 	add	r2, r2, #4	; 0x4
 3f4:	1afffff7 	bne	3d8 <uninstall_irq+0x18>
	{
	    *vect_addr = (DWORD)NULL;	/* clear the VIC entry in the VIC table */
	    *vect_cntl &= ~IRQ_SLOT_EN;	/* disable SLOT_EN bit */	
	    break;
	}
    }
    if ( i == VIC_SIZE )
 3f8:	e3a00000 	mov	r0, #0	; 0x0
 3fc:	e12fff1e 	bx	lr
 400:	e5823000 	str	r3, [r2]
 404:	e3a03000 	mov	r3, #0	; 0x0
 408:	e5023100 	str	r3, [r2, #-256]
    {
	return( FALSE );		/* fatal error, can't find interrupt number 
					in vector slot */
    }
    VICIntEnable = 1 << IntNumber;	/* Enable Interrupt */
 40c:	e3a00001 	mov	r0, #1	; 0x1
 410:	e3e03000 	mvn	r3, #0	; 0x0
 414:	e503cfef 	str	ip, [r3, #-4079]
    return( TRUE );
}
 418:	e12fff1e 	bx	lr
 41c:	fffff200 	undefined instruction 0xfffff200

00000420 <IRQ_Exception>:
** 
*****************************************************************************/
void IRQ_Exception(void) __irq;
void IRQ_Exception(void) __irq  
{
 420:	eafffffe 	b	420 <IRQ_Exception>

00000424 <FIQ_Exception>:
    while(1);                   /*  change it to your code */
}

/*****************************************************************************
** Function name:		FIQ_Exception
**
** Descriptions:		Fast interrupt exceptional handler , change it as needed
**
** parameters:			None
** Returned value:		None
**
******************************************************************************/
void FIQ_Exception(void) __fiq;
void FIQ_Exception(void) __fiq 
{
 424:	eafffffe 	b	424 <FIQ_Exception>

00000428 <TargetInit>:
    while(1);                   /* change it to your code */
}

/******************************************************************************
** Function name:		TargetInit
**
** Descriptions:		Initialize the target board; it is called in a necessary 
**				place, change it as needed
**
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
void TargetInit(void)
{
    /* Add your codes here */
}
 428:	e12fff1e 	bx	lr

0000042c <TargetResetInit>:

/******************************************************************************
** Function name:		TargetResetInit
**
** Descriptions:		Initialize the target board before running the main() 
**				function; User may change it as needed, but may not 
**				deleted it.
**
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
/* mthomas: all reset-initialisation is done in startup.S */
void TargetResetInit(void)
{
#ifdef __DEBUG_RAM    
    MEMMAP = 0x2;                   /* set remap register */
#endif

#ifdef __DEBUG_FLASH    
    MEMMAP = 0x1;                   /* set remap register */
#endif

#ifdef __IN_CHIP    
    MEMMAP = 0x1;                   /* set remap register */
#endif

    /* Set system timers for each component */
    PLLCON = 1;
 42c:	e59f2064 	ldr	r2, [pc, #100]	; 498 <.text+0x498>
 430:	e3a03001 	mov	r3, #1	; 0x1
 434:	e5823080 	str	r3, [r2, #128]
#if (Fpclk / (Fcclk / 4)) == 1
    VPBDIV = 0;
 438:	e3a03000 	mov	r3, #0	; 0x0
 43c:	e5823100 	str	r3, [r2, #256]
#endif
#if (Fpclk / (Fcclk / 4)) == 2
    VPBDIV = 2;
#endif
#if (Fpclk / (Fcclk / 4)) == 4
    VPBDIV = 1;
#endif

#if (Fcco / Fcclk) == 2
    PLLCFG = ((Fcclk / Fosc) - 1) | (0 << 5);
#endif
#if (Fcco / Fcclk) == 4
    PLLCFG = ((Fcclk / Fosc) - 1) | (1 << 5);
 440:	e2833024 	add	r3, r3, #36	; 0x24
 444:	e5823084 	str	r3, [r2, #132]
#endif
#if (Fcco / Fcclk) == 8
    PLLCFG = ((Fcclk / Fosc) - 1) | (2 << 5);
#endif
#if (Fcco / Fcclk) == 16
    PLLCFG = ((Fcclk / Fosc) - 1) | (3 << 5);
#endif
    PLLFEED = 0xaa;
 448:	e2833086 	add	r3, r3, #134	; 0x86
 44c:	e582308c 	str	r3, [r2, #140]
    PLLFEED = 0x55;
 450:	e3a03055 	mov	r3, #85	; 0x55
 454:	e582308c 	str	r3, [r2, #140]
    while((PLLSTAT & (1 << 10)) == 0);
 458:	e59f1038 	ldr	r1, [pc, #56]	; 498 <.text+0x498>
 45c:	e5913088 	ldr	r3, [r1, #136]
 460:	e3130b01 	tst	r3, #1024	; 0x400
 464:	0afffffb 	beq	458 <TargetResetInit+0x2c>
    PLLCON = 3;
 468:	e3a02003 	mov	r2, #3	; 0x3
    PLLFEED = 0xaa;
 46c:	e3a030aa 	mov	r3, #170	; 0xaa
 470:	e5812080 	str	r2, [r1, #128]
 474:	e581308c 	str	r3, [r1, #140]
    PLLFEED = 0x55;
 478:	e3a03055 	mov	r3, #85	; 0x55
 47c:	e581308c 	str	r3, [r1, #140]
    
    /* Set memory accelerater module*/
    MAMCR = 0;
 480:	e3a03000 	mov	r3, #0	; 0x0
 484:	e5813000 	str	r3, [r1]
#if Fcclk < 20000000
    MAMTIM = 1;
#else
#if Fcclk < 40000000
    MAMTIM = 2;
#else
    MAMTIM = 3;
#endif
#endif
    MAMCR = 2;
 488:	e2833002 	add	r3, r3, #2	; 0x2
 48c:	e5812004 	str	r2, [r1, #4]
 490:	e5813000 	str	r3, [r1]
    
    /* Add your codes here */
    return;
}
 494:	e12fff1e 	bx	lr
 498:	e01fc000 	ands	ip, pc, r0

0000049c <Timer0Handler>:
// mthomas: static inserted to avoid warning by gcc 4.1.0
#if 1
static void /*RAMFUNC*/ Timer0Handler (void) __irq
{  
    T0IR = 1;			/* clear interrupt flag */
 49c:	e59f3024 	ldr	r3, [pc, #36]	; 4c8 <.text+0x4c8>
 4a0:	e3a02001 	mov	r2, #1	; 0x1
 4a4:	e5832000 	str	r2, [r3]
    IENABLE;			/* handles nested interrupt */

    timer_counter++;
 4a8:	e59f201c 	ldr	r2, [pc, #28]	; 4cc <.text+0x4cc>
 4ac:	e5923000 	ldr	r3, [r2]
 4b0:	e2833001 	add	r3, r3, #1	; 0x1
 4b4:	e5823000 	str	r3, [r2]

    IDISABLE;
    VICVectAddr = 0;		/* Acknowledge Interrupt */
 4b8:	e3a02000 	mov	r2, #0	; 0x0
 4bc:	e3e03000 	mvn	r3, #0	; 0x0
 4c0:	e5032fcf 	str	r2, [r3, #-4047]
}
 4c4:	e12fff1e 	bx	lr
 4c8:	e0004000 	and	r4, r0, r0
 4cc:	40000000 	andmi	r0, r0, r0

000004d0 <enable_timer>:
#endif

#if 0
// mthomas: macro-approach - not needed since there
// is an assembler-wrapper provided in Startup.S
static void NACKEDFUNC Timer0Handler (void) __irq
{  
	ISR_STORE();
    T0IR = 1;			/* clear interrupt flag */
	ISR_ENABLE_NEST();  /* handles nested interrupt */

    timer_counter++;

	ISR_DISABLE_NEST();     /* Disable Interrupt nesting */
    VICVectAddr = 0;		/* Acknowledge Interrupt */
	ISR_RESTORE();
}
#endif

/******************************************************************************
** Function name:		enable_timer
**
** Descriptions:		Enable timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void enable_timer( BYTE timer_num )
{
    if ( timer_num == 0 )
 4d0:	e31000ff 	tst	r0, #255	; 0xff
    {
	T0TCR = 1;
 4d4:	059f3010 	ldreq	r3, [pc, #16]	; 4ec <.text+0x4ec>
    }
    else
    {
	T1TCR = 1;
 4d8:	159f3010 	ldrne	r3, [pc, #16]	; 4f0 <.text+0x4f0>
 4dc:	03a02001 	moveq	r2, #1	; 0x1
 4e0:	13a02001 	movne	r2, #1	; 0x1
 4e4:	e5832004 	str	r2, [r3, #4]
 4e8:	e12fff1e 	bx	lr
 4ec:	e0004000 	and	r4, r0, r0
 4f0:	e0008000 	and	r8, r0, r0

000004f4 <disable_timer>:
    }
    return;
}

/******************************************************************************
** Function name:		disable_timer
**
** Descriptions:		Disable timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void disable_timer( BYTE timer_num )
{
    if ( timer_num == 0 )
 4f4:	e21000ff 	ands	r0, r0, #255	; 0xff
    {
	T0TCR = 0;
 4f8:	059f3010 	ldreq	r3, [pc, #16]	; 510 <.text+0x510>
    }
    else
    {
	T1TCR = 0;
 4fc:	159f3010 	ldrne	r3, [pc, #16]	; 514 <.text+0x514>
 500:	13a02000 	movne	r2, #0	; 0x0
 504:	05830004 	streq	r0, [r3, #4]
 508:	15832004 	strne	r2, [r3, #4]
 50c:	e12fff1e 	bx	lr
 510:	e0004000 	and	r4, r0, r0
 514:	e0008000 	and	r8, r0, r0

00000518 <reset_timer>:
    }
    return;
}

/******************************************************************************
** Function name:		reset_timer
**
** Descriptions:		Reset timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void reset_timer( BYTE timer_num )
{
    DWORD regVal;

    if ( timer_num == 0 )
    {
	regVal = T0TCR;
	regVal |= 0x02;
	T0TCR = regVal;
    }
    else
    {
	regVal = T1TCR;
 518:	e59f1020 	ldr	r1, [pc, #32]	; 540 <.text+0x540>
 51c:	e59f2020 	ldr	r2, [pc, #32]	; 544 <.text+0x544>
 520:	e31000ff 	tst	r0, #255	; 0xff
 524:	05923004 	ldreq	r3, [r2, #4]
 528:	15913004 	ldrne	r3, [r1, #4]
 52c:	03833002 	orreq	r3, r3, #2	; 0x2
	regVal |= 0x02;
 530:	13833002 	orrne	r3, r3, #2	; 0x2
 534:	05823004 	streq	r3, [r2, #4]
	T1TCR = regVal;
 538:	15813004 	strne	r3, [r1, #4]
 53c:	e12fff1e 	bx	lr
 540:	e0008000 	and	r8, r0, r0
 544:	e0004000 	and	r4, r0, r0

00000548 <init_timer>:
    }
    return;
}

/******************************************************************************
** Function name:		init_timer
**
** Descriptions:		Initialize timer, set timer interval, reset timer,
**				install timer interrupt handler
**
** parameters:			None
** Returned value:		true or false, if the interrupt handler can't be
**				installed, return false.
** 
******************************************************************************/
DWORD init_timer (void) 
{
    timer_counter = 0;
 548:	e59f3038 	ldr	r3, [pc, #56]	; 588 <.text+0x588>
 54c:	e3a02000 	mov	r2, #0	; 0x0
 550:	e5832000 	str	r2, [r3]
    T0MR0 = INTERVAL_1S;	/* 50 * 10mSec = 50 * (150.000-1) counts */
 554:	e59fc030 	ldr	ip, [pc, #48]	; 58c <.text+0x58c>
 558:	e59f3030 	ldr	r3, [pc, #48]	; 590 <.text+0x590>
 55c:	e58c3018 	str	r3, [ip, #24]
    T0MCR = 3;			/* Interrupt and Reset on MR0 */
 560:	e3a03003 	mov	r3, #3	; 0x3
 564:	e52de004 	str	lr, [sp, #-4]!
    if ( install_irq( TIMER0_INT, (void *)Timer0Handler ) == FALSE )
 568:	e59f1024 	ldr	r1, [pc, #36]	; 594 <.text+0x594>
 56c:	e58c3014 	str	r3, [ip, #20]
 570:	e3a00004 	mov	r0, #4	; 0x4
 574:	ebffff78 	bl	35c <install_irq>
    {
	return (FALSE);
    }
    else
    {
	return (TRUE);
    }
}
 578:	e2500000 	subs	r0, r0, #0	; 0x0
 57c:	13a00001 	movne	r0, #1	; 0x1
 580:	e49de004 	ldr	lr, [sp], #4
 584:	e12fff1e 	bx	lr
 588:	40000000 	andmi	r0, r0, r0
 58c:	e0004000 	and	r4, r0, r0
 590:	00e4e15c 	rsceq	lr, r4, ip, asr r1
 594:	0000049c 	muleq	r0, ip, r4

00000598 <digitalWrite>:
	return 0;
}

int digitalWrite( DWORD state ){
	switch( state ){
 598:	2800      	cmp	r0, #0
 59a:	d002      	beq.n	5a2 <digitalWrite+0xa>
 59c:	2801      	cmp	r0, #1
 59e:	d108      	bne.n	5b2 <digitalWrite+0x1a>
 5a0:	e001      	b.n	5a6 <digitalWrite+0xe>
		case 0:
			IOCLR0 |= ( 1<< 8 );
 5a2:	4905      	ldr	r1, [pc, #20]	(5b8 <.text+0x5b8>)
 5a4:	e000      	b.n	5a8 <digitalWrite+0x10>
		break;
		case 1:
			IOSET0 |= ( 1 << 8 );
 5a6:	4905      	ldr	r1, [pc, #20]	(5bc <.text+0x5bc>)
 5a8:	680a      	ldr	r2, [r1, #0]
 5aa:	2380      	movs	r3, #128
 5ac:	005b      	lsls	r3, r3, #1
 5ae:	431a      	orrs	r2, r3
 5b0:	600a      	str	r2, [r1, #0]
		break;
	}
	return 0;
}
 5b2:	2000      	movs	r0, #0
 5b4:	4770      	bx	lr
 5b6:	0000      	lsls	r0, r0, #0
 5b8:	800c      	strh	r4, [r1, #0]
 5ba:	e002      	b.n	5c2 <main+0x2>
 5bc:	8004      	strh	r4, [r0, #0]
 5be:	e002      	b.n	5c6 <main+0x6>

000005c0 <main>:
 5c0:	b510      	push	{r4, lr}
 5c2:	4a12      	ldr	r2, [pc, #72]	(60c <.text+0x60c>)
 5c4:	2300      	movs	r3, #0
 5c6:	6013      	str	r3, [r2, #0]
 5c8:	f000 f826 	bl	618 <__init_VIC_from_thumb>
 5cc:	f000 f828 	bl	620 <__init_timer_from_thumb>
 5d0:	2000      	movs	r0, #0
 5d2:	f000 f829 	bl	628 <__enable_timer_from_thumb>
 5d6:	490e      	ldr	r1, [pc, #56]	(610 <.text+0x610>)
 5d8:	2280      	movs	r2, #128
 5da:	680b      	ldr	r3, [r1, #0]
 5dc:	0052      	lsls	r2, r2, #1
 5de:	4313      	orrs	r3, r2
 5e0:	600b      	str	r3, [r1, #0]
 5e2:	3904      	subs	r1, #4
 5e4:	680b      	ldr	r3, [r1, #0]
 5e6:	4313      	orrs	r3, r2
 5e8:	600b      	str	r3, [r1, #0]
 5ea:	2200      	movs	r2, #0
 5ec:	4c07      	ldr	r4, [pc, #28]	(60c <.text+0x60c>)
 5ee:	6823      	ldr	r3, [r4, #0]
 5f0:	1a9b      	subs	r3, r3, r2
 5f2:	2b01      	cmp	r3, #1
 5f4:	d1fa      	bne.n	5ec <main+0x2c>
 5f6:	4a07      	ldr	r2, [pc, #28]	(614 <.text+0x614>)
 5f8:	6813      	ldr	r3, [r2, #0]
 5fa:	2000      	movs	r0, #0
 5fc:	2b00      	cmp	r3, #0
 5fe:	d100      	bne.n	602 <main+0x42>
 600:	2001      	movs	r0, #1
 602:	6010      	str	r0, [r2, #0]
 604:	f7ff ffc8 	bl	598 <digitalWrite>
 608:	6822      	ldr	r2, [r4, #0]
 60a:	e7ef      	b.n	5ec <main+0x2c>
 60c:	0000      	lsls	r0, r0, #0
 60e:	4000      	ands	r0, r0
 610:	8008      	strh	r0, [r1, #0]
 612:	e002      	b.n	61a <__init_VIC_from_thumb+0x2>
 614:	0004      	lsls	r4, r0, #0
 616:	4000      	ands	r0, r0

00000618 <__init_VIC_from_thumb>:
 618:	4778      	bx	pc
 61a:	46c0      	nop			(mov r8, r8)

0000061c <__init_VIC_change_to_arm>:
 61c:	eaffff3d 	b	318 <init_VIC>

00000620 <__init_timer_from_thumb>:
 620:	4778      	bx	pc
 622:	46c0      	nop			(mov r8, r8)

00000624 <__init_timer_change_to_arm>:
 624:	eaffffc7 	b	548 <init_timer>

00000628 <__enable_timer_from_thumb>:
 628:	4778      	bx	pc
 62a:	46c0      	nop			(mov r8, r8)

0000062c <__enable_timer_change_to_arm>:
 62c:	eaffffa7 	b	4d0 <enable_timer>
